<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1920, height=1080">
    <title>TikHub - Lucky Wheel Overlay</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 1920px;
            height: 1080px;
            overflow: hidden;
            background: transparent;
            font-family: 'Arial', sans-serif;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #wheel-container {
            position: relative;
            width: 600px;
            height: 600px;
            display: none;
        }

        #wheel-container.active {
            display: block;
        }

        canvas {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 10px 40px rgba(0, 0, 0, 0.5));
        }

        .wheel-pointer {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 30px solid transparent;
            border-right: 30px solid transparent;
            border-top: 60px solid #ff4444;
            filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
            z-index: 10;
        }

        .winner-announcement {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #ff6b6b, #ff8787);
            padding: 40px 60px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
            display: none;
            animation: winner-pop 0.5s ease-out;
            z-index: 100;
        }

        .winner-announcement.show {
            display: block;
        }

        .winner-text {
            font-size: 48px;
            font-weight: bold;
            color: white;
            text-align: center;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .winner-prize {
            font-size: 36px;
            color: #fff9c4;
            text-align: center;
            margin-top: 20px;
        }

        @keyframes winner-pop {
            0% {
                transform: translate(-50%, -50%) scale(0);
                opacity: 0;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.2);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        #connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 20px;
            font-size: 12px;
            font-family: monospace;
            z-index: 10000;
        }

        #connection-status.connected {
            background: rgba(0, 200, 0, 0.7);
        }

        #connection-status.disconnected {
            background: rgba(200, 0, 0, 0.7);
        }
    </style>
</head>
<body>
    <div id="connection-status">Connecting...</div>
    
    <div id="wheel-container">
        <div class="wheel-pointer"></div>
        <canvas id="wheel-canvas"></canvas>
    </div>

    <div id="winner-announcement" class="winner-announcement">
        <div class="winner-text">üéâ WINNER! üéâ</div>
        <div class="winner-prize" id="prize-text"></div>
    </div>

    <script>
        // Configuration - CHANGE THIS TO YOUR RENDER.COM URL
        const OVERLAY_SERVER_URL = 'wss://your-overlay-server.onrender.com';
        const WS_PATH = '/ws/luckywheel';
        
        let ws = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 10;
        
        const statusEl = document.getElementById('connection-status');
        const wheelContainer = document.getElementById('wheel-container');
        const canvas = document.getElementById('wheel-canvas');
        const ctx = canvas.getContext('2d');
        const winnerAnnouncement = document.getElementById('winner-announcement');
        const prizeText = document.getElementById('prize-text');
        
        let wheelConfig = null;
        let currentRotation = 0;
        let isSpinning = false;
        
        // Setup canvas
        canvas.width = 600;
        canvas.height = 600;
        
        // Connect to WebSocket
        function connect() {
            try {
                ws = new WebSocket(OVERLAY_SERVER_URL + WS_PATH);
                
                ws.onopen = () => {
                    console.log('‚úÖ Connected to TikHub Overlay Server');
                    statusEl.textContent = 'Connected';
                    statusEl.className = 'connected';
                    reconnectAttempts = 0;
                };
                
                ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        console.log('üì• Received:', data);
                        
                        if (data.type === 'wheel-config-update') {
                            wheelConfig = data.config;
                            drawWheel();
                        } else if (data.type === 'wheel-spin') {
                            spinWheel(data);
                        } else if (data.type === 'initial-state' && data.state) {
                            wheelConfig = data.state;
                            drawWheel();
                        }
                    } catch (error) {
                        console.error('Error processing message:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'Error';
                    statusEl.className = 'disconnected';
                };
                
                ws.onclose = () => {
                    console.log('‚ùå Disconnected from server');
                    statusEl.textContent = 'Disconnected';
                    statusEl.className = 'disconnected';
                    
                    if (reconnectAttempts < maxReconnectAttempts) {
                        reconnectAttempts++;
                        const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                        console.log(`Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                        setTimeout(connect, delay);
                    }
                };
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
            }
        }
        
        // Draw wheel
        function drawWheel() {
            if (!wheelConfig || !wheelConfig.segments || wheelConfig.segments.length === 0) {
                return;
            }
            
            wheelContainer.classList.add('active');
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 250;
            const segmentCount = wheelConfig.segments.length;
            const anglePerSegment = (2 * Math.PI) / segmentCount;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw segments
            wheelConfig.segments.forEach((segment, index) => {
                const startAngle = currentRotation + index * anglePerSegment;
                const endAngle = startAngle + anglePerSegment;
                
                // Segment
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, startAngle, endAngle);
                ctx.closePath();
                ctx.fillStyle = segment.color || `hsl(${(index * 360) / segmentCount}, 70%, 60%)`;
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Text
                ctx.save();
                ctx.translate(centerX, centerY);
                ctx.rotate(startAngle + anglePerSegment / 2);
                ctx.textAlign = 'right';
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 20px Arial';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 4;
                ctx.fillText(segment.label || segment.name, radius - 20, 10);
                ctx.restore();
            });
            
            // Center circle
            ctx.beginPath();
            ctx.arc(centerX, centerY, 40, 0, 2 * Math.PI);
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 4;
            ctx.stroke();
        }
        
        // Spin wheel
        function spinWheel(data) {
            if (isSpinning) return;
            if (!wheelConfig || !wheelConfig.segments) return;
            
            isSpinning = true;
            wheelContainer.classList.add('active');
            
            const winnerIdx = data.winnerIdx;
            const segmentCount = wheelConfig.segments.length;
            const anglePerSegment = (2 * Math.PI) / segmentCount;
            
            // Calculate target rotation
            const baseRotation = Math.PI * 2 * 5; // 5 full rotations
            const targetSegmentAngle = winnerIdx * anglePerSegment;
            const offset = anglePerSegment / 2; // Point to center of segment
            const targetRotation = baseRotation - targetSegmentAngle - offset;
            
            const duration = 4000; // 4 seconds
            const startTime = Date.now();
            const startRotation = currentRotation;
            
            function animate() {
                const now = Date.now();
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Easing function (ease-out)
                const eased = 1 - Math.pow(1 - progress, 3);
                
                currentRotation = startRotation + targetRotation * eased;
                drawWheel();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    currentRotation = (startRotation + targetRotation) % (Math.PI * 2);
                    isSpinning = false;
                    showWinner(winnerIdx);
                }
            }
            
            animate();
        }
        
        // Show winner
        function showWinner(winnerIdx) {
            if (!wheelConfig || !wheelConfig.segments[winnerIdx]) return;
            
            const winner = wheelConfig.segments[winnerIdx];
            prizeText.textContent = winner.label || winner.name;
            
            winnerAnnouncement.classList.add('show');
            
            setTimeout(() => {
                winnerAnnouncement.classList.remove('show');
                setTimeout(() => {
                    wheelContainer.classList.remove('active');
                }, 1000);
            }, 3000);
        }
        
        // Auto-hide connection status
        setTimeout(() => {
            if (statusEl.className === 'connected') {
                statusEl.style.opacity = '0.3';
            }
        }, 5000);
        
        // Initialize
        connect();
        
        // Test function
        window.testSpin = () => {
            if (!wheelConfig) {
                wheelConfig = {
                    segments: [
                        { name: 'Prize 1', color: '#ff6b6b' },
                        { name: 'Prize 2', color: '#4ecdc4' },
                        { name: 'Prize 3', color: '#45b7d1' },
                        { name: 'Prize 4', color: '#f7b731' },
                        { name: 'Prize 5', color: '#5f27cd' },
                        { name: 'Prize 6', color: '#00d2d3' }
                    ]
                };
                drawWheel();
            }
            spinWheel({ winnerIdx: Math.floor(Math.random() * wheelConfig.segments.length) });
        };
    </script>
</body>
</html>

